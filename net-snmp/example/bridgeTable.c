/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

#include "bridgeTable.h"
#include "public.h"
#include "mib.h"

const oid bridgeTable_variables_oid[] = {BRIDGE_TABLE_OID};

enum BRIDGETABLE_MAGIC
{
	BRID = 1,
	BRIFID,
	BRNAME,
	BRIFNAME
};

struct variable bridgeTable_variables[] = {
/*
 * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix 
 */
{BRID, 		ASN_INTEGER, 	NETSNMP_OLDAPI_RWRITE,	var_bridgeTable, 2, {1, 1}},
{BRIFID, 	ASN_INTEGER,	NETSNMP_OLDAPI_RWRITE,	var_bridgeTable, 2, {1, 2}},
{BRNAME, 	ASN_OCTET_STR, 	NETSNMP_OLDAPI_RWRITE,	var_bridgeTable, 2, {1, 3}},
{BRIFNAME, 	ASN_OCTET_STR, 	NETSNMP_OLDAPI_RWRITE,	var_bridgeTable, 2, {1, 4}},
};
struct bridgeTable_entry *bridgeTable_head = NULL;

struct bridgeTable_entry *bridgeTable_createEntry(struct bridgeTable_entry*pdata)
{
    struct bridgeTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct bridgeTable_entry);
    if (!entry)
        return NULL;

	memset(entry,0,sizeof(struct bridgeTable_entry));

	entry->brID = pdata->brID;
    entry->ifID = pdata->ifID;
    
	sprintf(entry->brName,"br%d",entry->brID);
	entry->brName_len = strlen(entry->brName);

	strncpy(entry->ifName,pdata->ifName,strlen(pdata->ifName));
	entry->ifName_len = strlen(entry->ifName);
	
   	syslog(LOG_INFO,"Data instert:[%s - %s]\n",entry->brName,entry->ifName);
    entry->next = bridgeTable_head;
    bridgeTable_head = entry;
    return entry;
}

struct bridgeTable_entry * bridgeTable_getEntryByIndex(long brID,long ifID)
{
    struct bridgeTable_entry *ptr, *prev;

    for (ptr = bridgeTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
		if((ptr->brID == brID) && (ptr->ifID == ifID))
			return ptr;
    }
    return NULL;
}
void bridgeTable_removeEntry(struct bridgeTable_entry *entry)
{
    struct bridgeTable_entry *ptr, *prev;
    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = bridgeTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        bridgeTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}

void init_bridge_data(void)
{
	FILE *f = NULL;
	FILE *f2 = NULL;
	char buf[128],*p;
	struct bridgeTable_entry data;
	char cmd[128];
	int index = 1,ret;
	f = popen("brctl show| grep -v bridge |awk 'NF>2 {print $1}'","r");
	if(NULL == f)
	{
		syslog(LOG_ERR,"popen err:$s\n",strerror(errno));
		return;
	}
	memset(buf,0,128);
	
	while(NULL != fgets(buf,sizeof(buf),f))
	{
		memset(&data,0,sizeof(struct bridgeTable_entry));
		buf[strlen(buf) -1] = '\0';
		
		if(strlen(buf) == 0) continue;
			
		data.brID = index;
		strncpy(data.brName,buf,strlen(buf));
		data.brName_len = strlen(data.brName);
		
		/*get interface on bridge*/
		memset(cmd,0,128);
		sprintf(cmd,"ls -l /sys/devices/virtual/net/%s/brif/ | awk '{print $9}'",data.brName);
		
		f2 = popen(cmd,"r");
		if(NULL == f2)
		{
			syslog(LOG_ERR,"popen err:$s\n",strerror(errno));
			continue;
		}
		memset(buf,0,sizeof(buf));
		while(NULL != fgets(buf,sizeof(buf),f2))
		{
			buf[strlen(buf) -1] = '\0';
			
			if(strlen(buf) == 0) continue;

			strncpy(data.ifName,buf,strlen(buf));
			data.ifName_len = strlen(data.ifName);

			ret = ifInfoTable_getIdByname(data.ifName);
			if(-1 == ret) continue;

			data.ifID = ret;

			/*add list*/
			bridgeTable_createEntry(&data);
			memset(buf,0,sizeof(buf));
			syslog(LOG_INFO,"%s - %s\n",data.brName,data.ifName);
		}
		pclose(f2);
		index++;
		memset(buf,0,sizeof(buf));
	}
	pclose(f);

	return;
}
/** Initializes the bridgeTable module */
void init_bridgeTable_mib(void)
{
    DEBUGMSGTL(("bridgeTable", "Initializing\n"));
    REGISTER_MIB("bridgeTable", bridgeTable_variables, variable,
                 bridgeTable_variables_oid);
}

unsigned char  *var_bridgeTable(struct variable *vp,
                oid * name,
                size_t *length,
                int exact, size_t *var_len, WriteMethod ** write_method)
{
	long index_brid,index_ifid;
	char buf[256];
	struct bridgeTable_entry *pdata = NULL;

	memset(buf,0,sizeof(buf));
	sprint_mib_oid(buf,name,*length);
	syslog(LOG_INFO,"MIB:%s\n",buf);
	
    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED)
        return NULL;
        
	memset(buf,0,sizeof(buf));
	sprint_mib_oid(buf,name,*length);
	syslog(LOG_INFO,"-----------MIB:%s\n",buf);

    /*
     * this is where we do the value assignments for the mib results.
     */
	*write_method = write_bridgeTable;

	if(*length == (sizeof(bridgeTable_variables_oid)/sizeof(oid) + 2))
		pdata = bridgeTable_head;
	else{
		index_brid = name[*length -2];
		index_ifid = name[*length -1];
		pdata = bridgeTable_getEntryByIndex(index_brid,index_ifid);
		if(NULL == pdata)
			return NULL;
	}
    switch (vp->magic) {
    case BRID:
        return (u_char *) &(pdata->brID);
    case BRIFID:
        return (u_char *) &(pdata->ifID);
    case BRNAME:
        return (u_char *) pdata->brName;
    case BRIFNAME:
        return (u_char *) pdata->ifName;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int write_bridgeTable(int action,
		           u_char * var_val,
		           u_char var_val_type,
		           size_t var_val_len, u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
    /*
        if (var_val_type != ASN_INTEGER) {
            syslog(LOG_ERR, "write to bridgeTable not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to bridgeTable: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
    */
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

void init_bridgeTable(void)
{
	init_bridge_data();
	init_bridgeTable_mib();
}
