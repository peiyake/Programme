/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <unistd.h>
#include <string.h>
#include <sys/utsname.h>
#include <linux/sysinfo.h>

#include "devinfo.h"
#include "public.h"
#include "mib.h"

/*devinfo scalar node oid*/
const oid oid_devinfo_scalar_hostname[] = {DEVINFO_SCALAR_HOSTNAME};
const oid oid_devinfo_scalar_systemtype[] = {DEVINFO_SCALAR_SYSTEMTYPE};
const oid oid_devinfo_scalar_kernelversion[] = {DEVINFO_SCALAR_KERNELVERSION};
const oid oid_devinfo_scalar_uptime[] = {DEVINFO_SCALAR_UPTIME};
const oid oid_devinfo_scalar_ipforward[] = {DEVINFO_SCALAR_IPFORWARD};
const oid oid_devinfo_scalar_cpu[] = {DEVINFO_SCALAR_CPU};
const oid oid_devinfo_scalar_mem[] = {DEVINFO_SCALAR_MEM};

devinfo_node_data_t devinfo;
mib_node_info_t devinfo_node[]={
	{"hostname",		oid_devinfo_scalar_hostname,		OID_LENGTH(oid_devinfo_scalar_hostname),		HANDLER_CAN_RONLY},
	{"systemtype",		oid_devinfo_scalar_systemtype,		OID_LENGTH(oid_devinfo_scalar_systemtype),		HANDLER_CAN_RONLY},
	{"kernelVersion",	oid_devinfo_scalar_kernelversion,	OID_LENGTH(oid_devinfo_scalar_kernelversion),	HANDLER_CAN_RONLY},
	{"uptime",			oid_devinfo_scalar_uptime,			OID_LENGTH(oid_devinfo_scalar_uptime),			HANDLER_CAN_RONLY},
	{"ipforward",		oid_devinfo_scalar_ipforward,		OID_LENGTH(oid_devinfo_scalar_ipforward),		HANDLER_CAN_RWRITE},
	{"cpu",				oid_devinfo_scalar_cpu,				OID_LENGTH(oid_devinfo_scalar_cpu),				HANDLER_CAN_RONLY},
	{"mem",				oid_devinfo_scalar_mem,				OID_LENGTH(oid_devinfo_scalar_mem),				HANDLER_CAN_RONLY}
};
void get_sysinfo(void)
{
	int ret;
	struct sysinfo info;
	/*uptime cpu mem*/
	ret = sysinfo(&info);
	if(-1 == ret)
		syslog(LOG_ERR,"get sysinfo failed\n");
	else{
		devinfo.uptime = info.uptime * 100; /*units:0.01s*/
		devinfo.mem = 100 *(info.totalram - info.freeram)/info.totalram;
		devinfo.cpu = info.loads[0];
	}
	return;
}
void get_hostname(void)
{
	int ret = -1;
	/*get hostname*/
	ret = gethostname(devinfo.hostname,32);
	if(-1 == ret) 
		syslog(LOG_ERR,"get hostname failed!\n");
	return;
}
void get_system(void)
{
	int ret = -1;
	struct utsname buf;

	/*systemtype kernelversion*/
	ret = uname(&buf);
	if(-1 == ret) 
		syslog(LOG_ERR,"get uname failed!\n");
	else{
		strncpy(devinfo.systemtype,buf.nodename,sizeof(devinfo.systemtype));
		strncpy(devinfo.kernelver,buf.release,sizeof(devinfo.kernelver));
	}
	return;
}
void init_devinfo_data(void)
{
	memset(&devinfo,0,sizeof(devinfo));
	get_hostname();
	get_system();
	get_sysinfo();
	syslog(LOG_INFO,"init_devinfo_data:hostname[%s],systemtype[%s],kerver[%s],uptime[%ld],cpu[%d],mem[%d]\n",
					devinfo.hostname,
					devinfo.systemtype,
					devinfo.kernelver,
					devinfo.uptime,
					devinfo.cpu,
					devinfo.mem);	
}
/** Initializes the devinfo module */
void init_devinfo_mib(void)
{
	mib_node_info_t *pmib = devinfo_node;
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            (pmib->nodename, handle_hostname, pmib->nodeoid,
                             pmib->oid_len, pmib->permission));
    pmib++;
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            (pmib->nodename, handle_systemtype, pmib->nodeoid,
                             pmib->oid_len, pmib->permission));
    pmib++;
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            (pmib->nodename, handle_kernelVersion, pmib->nodeoid,
                             pmib->oid_len, pmib->permission));
    pmib++;
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            (pmib->nodename, handle_uptime, pmib->nodeoid,
                             pmib->oid_len, pmib->permission));
    pmib++;
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            (pmib->nodename, handle_ipforward, pmib->nodeoid,
                             pmib->oid_len, pmib->permission));
    pmib++;
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            (pmib->nodename, handle_cpu, pmib->nodeoid,
                             pmib->oid_len, pmib->permission));
    pmib++;
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            (pmib->nodename, handle_mem, pmib->nodeoid,
                             pmib->oid_len, pmib->permission));
}

int handle_hostname(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
        						(const void*)devinfo.hostname,
        						strlen(devinfo.hostname));
     	break;
    default:
        syslog(LOG_ERR, "unknown mode (%d) in handle_hostname\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int handle_systemtype(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
								(const void*)devinfo.systemtype,
								strlen(devinfo.systemtype));
        break;
	default:
		syslog(LOG_ERR, "unknown mode (%d) in handle_hostname\n",
				 reqinfo->mode);
		return SNMP_ERR_GENERR;
	}
	return SNMP_ERR_NOERROR;
}

int handle_kernelVersion(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
								(const void *)devinfo.kernelver,
								strlen(devinfo.kernelver));
        break;
    default:
        syslog(LOG_ERR, "unknown mode (%d) in handle_kernelVersion\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int handle_uptime(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
    	get_sysinfo();
        snmp_set_var_typed_value(requests->requestvb, ASN_TIMETICKS,
								(const void*)&(devinfo.uptime),
								sizeof(devinfo.uptime));
        break;
    default:
        syslog(LOG_ERR, "unknown mode (%d) in handle_uptime\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int handle_ipforward(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    int             ret;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
								(const void*)&(devinfo.ipforward),
								sizeof(devinfo.ipforward));
        break;
    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;
    case MODE_SET_RESERVE2:
    	devinfo.old_ipforward = devinfo.ipforward;
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:	
        if ((*(requests->requestvb->val.integer) != 0) || 
        		(*(requests->requestvb->val.integer) != 1)) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;
        }
		devinfo.ipforward = *(requests->requestvb->val.integer);
        break;

    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
    	devinfo.ipforward = devinfo.old_ipforward;
        break;
    default:
        syslog(LOG_ERR, "unknown mode (%d) in handle_ipforward\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int handle_cpu(netsnmp_mib_handler *handler,
           netsnmp_handler_registration *reginfo,
           netsnmp_agent_request_info *reqinfo,
           netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
    	get_sysinfo();
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
								(const void*)&(devinfo.cpu),
								sizeof(devinfo.cpu));
        break;
    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_cpu\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int handle_mem(netsnmp_mib_handler *handler,
           netsnmp_handler_registration *reginfo,
           netsnmp_agent_request_info *reqinfo,
           netsnmp_request_info *requests)
{
    int             ret;
    switch (reqinfo->mode) {
    case MODE_GET:
    	get_sysinfo();
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
								(const void*)&(devinfo.mem),
								sizeof(devinfo.mem));
        break;
    default:
        syslog(LOG_ERR, "unknown mode (%d) in handle_mem\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

void init_devinfo(void)
{
   init_devinfo_data();
   init_devinfo_mib();
}

